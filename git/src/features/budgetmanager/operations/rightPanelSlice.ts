import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from 'app/store';
import { getUserImage, getRollupTaskData, fetchCompanyData } from './rightPanelAPI';

export interface RightPanelState {
	loading: boolean;
	selectedRow: any;
	userImage: any;
	selectedRowIndexData: any;
	lineItemId: string;
	openTransactionList: boolean;
	openCostForm: boolean;
	openBudgetTransferForm: boolean;
	rollupTaskData: any;
	companyList: any;
}

const initialState: RightPanelState = {
	loading: true,
	selectedRow: {},
	userImage: '',
	selectedRowIndexData: {},
	lineItemId: '',
	openTransactionList: false,
	openCostForm: false,
	openBudgetTransferForm: false,
	rollupTaskData: [],
	companyList: []
};

export const fetchUserImage: any = createAsyncThunk<any, any>(
	'rightPanel',
	async (obj) => {
		const response = await getUserImage(obj.appInfo, obj.userId);
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const fetchRollupTaskData: any = createAsyncThunk<any, any>(
	'RollupTaskData',
	async (obj) => {
		const response = await getRollupTaskData(obj.appInfo);
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const fetchCompanyList = createAsyncThunk<any, any>('companyList',
	async (obj) => {
		const response = await fetchCompanyData(obj.appInfo);
		return response;
	}
);

export const rightPanelSlice = createSlice({
	name: 'rightPanel',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setSelectedRowData: (state, action: PayloadAction<object>) => {
			state.selectedRow = action.payload;
			// state.lineItemId = action.payload['id'];
		},
		setSelectedRowIndex: (state, action: PayloadAction<any>) => {
			state.selectedRowIndexData = action.payload;
			// state.lineItemId = action.payload['id'];
		},
		setOpenTransactionList: (state, action: PayloadAction<boolean>) => {
			state.openTransactionList = action.payload;
		},
		setOpenCostForm: (state, action: PayloadAction<boolean>) => {
			state.openCostForm = action.payload;
		},
		setOpenBudgetTransferForm: (state, action: PayloadAction<boolean>) => {
			state.openBudgetTransferForm = action.payload;
		}
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(fetchUserImage.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchUserImage.fulfilled, (state, action) => {
				state.loading = false;
				state.userImage = action.payload;
			})
			.addCase(fetchUserImage.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchRollupTaskData.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchRollupTaskData.fulfilled, (state, action) => {
				state.loading = false;
				const newOptions = action.payload.map((type: any) => {
					return { label: type.name, value: type.id, budgetItemId: type.budgetItemId, description: 'Roll Up Tag/WBS is already mapped to the Work Item and is not available for selection' };
				});
				state.rollupTaskData = newOptions;
			})
			.addCase(fetchRollupTaskData.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchCompanyList.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchCompanyList.fulfilled, (state, action) => {
				state.companyList = action.payload;
			})
			.addCase(fetchCompanyList.rejected, (state) => {
				state.loading = false;
			});
		;

	}
});

export const getRollupsData = (state: RootState) => state?.rightPanel?.rollupTaskData;

export const { setSelectedRowData, setSelectedRowIndex, setOpenTransactionList, setOpenCostForm, setOpenBudgetTransferForm } = rightPanelSlice.actions;
export default rightPanelSlice.reducer;




// export const { actions: transactionsActions } = transactionsSlice;


// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
// 	(amount: number): AppThunk =>
// 		(dispatch, getState) => {
// 			const currentValue = selectCount(getState());
// 			if (currentValue % 2 === 1) {
// 				dispatch(incrementByAmount(amount));
// 			}
// 		};
