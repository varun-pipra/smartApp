import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { getForecastData } from './transactionsApi';
import { RootState } from "app/store";


export interface BudgetManagerForecastState {
	loading: boolean;
	forecastData: any;
	lineItemId: string;
	filteredRecords: any,
	callForecastApi: any
}

const initialState: BudgetManagerForecastState = {
	loading: false,
	lineItemId: '',
	forecastData: [],
	filteredRecords: [],
	callForecastApi: false
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchForecastData: any = createAsyncThunk<any, any, any>(
	'forecastData',
	async (obj) => {
		const response = await getForecastData(obj.appInfo, obj.id);
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);

export const forecastSlice = createSlice({
	name: 'forecastData',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setForecastData: (state, action: PayloadAction<any>) => {
			state.forecastData = action.payload;
		},
		setCallForecastApi: (state, action: PayloadAction<any>) => {
			state.callForecastApi = action.payload;
		},
		setFilteredRecords: (state, action: PayloadAction<any>) => {
			state.filteredRecords = action.payload;
		}
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(fetchForecastData.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchForecastData.fulfilled, (state, action) => {
				state.loading = false;
				state.forecastData = action.payload;
			})
			.addCase(fetchForecastData.rejected, (state) => {
				state.loading = false;
			});

	}
});
export const getForecastList = (state: RootState) => state.forecast.forecastData;
export const getFilteredRecords = (state: RootState) => state.forecast.filteredRecords;

export const { setForecastData, setFilteredRecords, setCallForecastApi } = forecastSlice.actions;
export default forecastSlice.reducer;