import { createAsyncThunk, createSlice, PayloadAction, combineReducers } from '@reduxjs/toolkit';
import { fetchGridDataList } from './gridAPI';
import { RootState } from 'app/store';
import { triggerEvent } from 'utilities/commonFunctions';
import { fetchSettingsData, fetchSettingsCostCodeAndTypeData, fetchdefaultData, fetchSecurityData } from './settingsAPI';
import { fetchCostCodeAndTypeDropdownData, fetchDivisionCostCodeFilterData } from './costcodeAPI';
export interface SettingsState {
	loading: boolean;
	settingsData: any;
	divisionCostCodeFilterData: any;
	costCodeDropdownData: any;
	costTypeDropdownData: any;
	CostCodeAndTypeData: any;
	defaultData: any;
	securityData: any;
	openAlert: boolean;
	divisionOrCostTypeChanged: boolean;
}

const initialState: SettingsState = {
	loading: false,
	settingsData: {},
	divisionCostCodeFilterData: [],
	costCodeDropdownData: [],
	costTypeDropdownData: [],
	CostCodeAndTypeData: [],
	defaultData: [],
	securityData: [],
	openAlert: false,
	divisionOrCostTypeChanged: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchSettings = createAsyncThunk<any, any>(
	'settingsData',
	async (appInfo) => {
		const response = await fetchSettingsData(appInfo);
		// The value we return becomes the `fulfilled` action payload
		return response;
	}
);
export const fetchSettingsCostCodeAndType = createAsyncThunk<any, any>(
	'CostCodeAndTypeData',
	async (appInfo) => {
		const response = await fetchSettingsCostCodeAndTypeData(appInfo);
		return response;
	}
);
export const fetchdefaultdrodown = createAsyncThunk<any, any>(
	'defaultData',
	async (appInfo) => {
		const response = await fetchdefaultData(appInfo);
		const newOptions = response.records.map((type: any) => {
			return { label: type.Text, value: type.smartAppUniqueId, img: type.ImgSrc };
		});
		return newOptions;
	}
);
export const fetchSecurity = createAsyncThunk<any, any>(
	'securityData',
	async (appInfo) => {
		const response = await fetchSecurityData(appInfo);
		return response;
	}
);

export const fetchDivisionCostCodeFilterList = createAsyncThunk<any, any>(
	'DCfilterData',
	async (payload) => {
		const response = await fetchDivisionCostCodeFilterData(payload.appInfo, payload.costCodeName);
		// console.log("repo", response);
		return response;
	}
)
export const fetchCostCodeDropdownList = createAsyncThunk<any, any>(
	'DCDropdownData',
	async (payload) => {
		const response = await fetchCostCodeAndTypeDropdownData(payload.appInfo, payload.name);
		return response;
	}
)
export const fetchCostTypeDropdownList = createAsyncThunk<any, any>(
	'costTypeDropdownData',
	async (payload) => {
		const response = await fetchCostCodeAndTypeDropdownData(payload.appInfo, payload.name);
		return response;
	}
)

export const settingsSlice = createSlice({
	name: 'settings',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setSettings: (state, action: PayloadAction<any>) => {
			state.settingsData = action.payload;
		},
		setSettingsCostCodeAndTypeList: (state, action: PayloadAction<any>) => {
			state.CostCodeAndTypeData = action.payload;
		},
		setDefaultData: (state, action: PayloadAction<any>) => {
			state.defaultData = action.payload;
		},
		setSecurity: (state, action: PayloadAction<any>) => {
			state.securityData = action.payload;
		},
		setOpenAlert: (state, action: PayloadAction<boolean>) => { state.openAlert = action.payload },
		setDivisionOrCostTypeChanged: (state, action: PayloadAction<boolean>) => {
			state.divisionOrCostTypeChanged = action.payload;
		},

	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(fetchSettings.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchSettings.fulfilled, (state, action) => {
				state.loading = false;
				state.settingsData = action.payload;
			})
			.addCase(fetchSettings.rejected, (state) => {
				state.loading = false;
			})

			.addCase(fetchSettingsCostCodeAndType.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchSettingsCostCodeAndType.fulfilled, (state, action) => {
				state.loading = false;
				state.CostCodeAndTypeData = action.payload;
			})
			.addCase(fetchSettingsCostCodeAndType.rejected, (state) => {
				state.loading = false;
			})

			.addCase(fetchdefaultdrodown.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchdefaultdrodown.fulfilled, (state, action) => {
				state.loading = false;
				state.defaultData = action.payload;
			})
			.addCase(fetchdefaultdrodown.rejected, (state) => {
				state.loading = false;
			})

			.addCase(fetchSecurity.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchSecurity.fulfilled, (state, action) => {
				state.loading = false;
				state.securityData = action.payload;
			})
			.addCase(fetchSecurity.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchDivisionCostCodeFilterList.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchDivisionCostCodeFilterList.fulfilled, (state, action) => {
				state.loading = false;
				// console.log("divisionCostCodeFilterData in slice", action.payload)
				state.divisionCostCodeFilterData = action.payload;
			})
			.addCase(fetchDivisionCostCodeFilterList.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchCostCodeDropdownList.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchCostCodeDropdownList.fulfilled, (state, action) => {
				state.loading = false;
				state.costCodeDropdownData = action.payload;
			})
			.addCase(fetchCostCodeDropdownList.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchCostTypeDropdownList.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchCostTypeDropdownList.fulfilled, (state, action) => {
				state.loading = false;
				state.costTypeDropdownData = action.payload;
			})
			.addCase(fetchCostTypeDropdownList.rejected, (state) => {
				state.loading = false;
			});;
	}
});



export const { setSettings, setSettingsCostCodeAndTypeList, setDefaultData, setSecurity, setDivisionOrCostTypeChanged, setOpenAlert } = settingsSlice.actions;

export const getCostCodeDropdownList = (state: RootState) => state.settings.costCodeDropdownData;
export const getCostCodeFilterList = (state: RootState) => state.settings.divisionCostCodeFilterData;


export default settingsSlice.reducer;
