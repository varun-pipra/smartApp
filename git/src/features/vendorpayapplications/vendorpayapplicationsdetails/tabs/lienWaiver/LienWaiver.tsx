import React, {useEffect, useMemo, useState, useRef, useCallback} from "react";
import {useAppSelector, useAppDispatch} from "app/hooks";
import "./LienWaiver.scss";
import {Checkbox, Button, Card} from "@mui/material";

import {
	getShowContractAttachments,
	setShowContractAttachments,
} from "features/vendorcontracts/stores/VendorContractsSlice";
import ContractAttachments from "features/supplementalcontracts/SupplementalContractsWindow";
import {appInfoData} from "data/appInfo";
import {getServer} from "app/common/appInfoSlice";
import {addContractFiles} from "features/vendorcontracts/stores/tabs/contractfiles/VCContractFilesTabSlice";
import LienFileViewer from "components/fileviewer/LienFileViewer";
import {patchVendorPayAppDetails} from "features/vendorpayapplications/stores/gridApi";
import {setEnableSubmitPayApp, setSelectedRecord, setSignatureToAuthorize} from "features/vendorpayapplications/stores/VendorPayAppSlice";
import {getAmountAlignment} from "utilities/commonutills";
import {ToWords} from 'to-words';
import SignatureCanvas from "react-signature-canvas";
import convertDateToDisplayFormat from "utilities/commonFunctions";
import {isUserGCForVPA} from "features/vendorpayapplications/utils";
import {amountFormatWithSymbol} from 'app/common/userLoginUtils';
import {currencyDescription} from "app/utils";


interface LienWaiverProps {
	readOnly?: boolean;
}

const LienWaiver = (props: LienWaiverProps) => {
	const dispatch = useAppDispatch();
	const [checked, setChecked] = useState(false);
	const [appData] = React.useState(appInfoData);
	const appInfo = useAppSelector(getServer);
	const [filesToView, setFilesToView] = useState<any>([]);
	const [showAmount, setShowAmount] = useState<boolean>(false);
	const [signedOn, setSignedOn] = useState<any>(null);
	const [userDetails, setUserDetails] = useState<any>({name: null, signedOn: null});
	const [gcAndScDetail, setGcAndScDetails] = useState<any>({gc: {name: null, signedOn: null}, sc: {name: null, signedOn: null}});

	const signaturePadRef = useRef<any>();

	const openContractAttachments = useAppSelector(getShowContractAttachments);
	const {selectedRecord} = useAppSelector((state) => state.vendorPayApps);
	const {currencySymbol} = useAppSelector((state) => state.appInfo);
	const [signature, setSignature] = useState<any>('');

	const toWords = new ToWords({localeCode: 'en-US'});

	React.useEffect(() => {
		if(isUserGCForVPA(appInfo)) {
			setSignature(selectedRecord?.gcAuthorization?.signature);
			setUserDetails(selectedRecord?.gcAuthorization?.displayName);
		}
		else {setSignature(selectedRecord?.scAuthorization?.signature); setUserDetails(selectedRecord?.scAuthorization?.displayName);}
	}, [selectedRecord, appInfo]);

	// React.useEffect(() => {
	// 	if(signaturePadRef?.current) {
	//     // signaturePadRef?.current?.off()
	//     isUserGCForVPA(appInfo) ?  signaturePadRef?.current?.fromDataURL(selectedRecord?.gcAuthorization?.signature) : signaturePadRef?.current?.fromDataURL(selectedRecord?.scAuthorization?.signature)	
	//   } 
	// }, [selectedRecord, signaturePadRef])

	React.useEffect(() => {
		if(['PaymentAuthorized', 'PaymentSent', 'PaymentReceived', 'Rejected', 'SubmittedWaitingForOtherParty']?.includes(selectedRecord?.status)) {setChecked(true); setShowAmount(true);}
		if(isUserGCForVPA(appInfo)) {
			if(["AutoGeneratedWaitingForBothParties", 'Draft']?.includes(selectedRecord?.status)) {
				if(selectedRecord?.gcAuthorization?.signature) {
					console.log("AutoGeneratedWaitingForBothParties if", selectedRecord, checked, showAmount);
					setChecked(true);
					setShowAmount(true);
				} else {
					setChecked(false);
					setShowAmount(false);
				}
			}
		}
		else {
			{
				if(["AutoGeneratedWaitingForBothParties", 'Draft']?.includes(selectedRecord?.status)) {
					if(selectedRecord?.scAuthorization?.signature) {
						console.log("AutoGeneratedWaitingForBothParties else", selectedRecord, showAmount, checked);
						setChecked(true);
						setShowAmount(true);
					} else {
						setChecked(false);
						setShowAmount(false);
					}
				}
				// if(['PaymentAuthorized', 'PaymentSent', 'PaymentReceived' , 'Rejected']?.includes(selectedRecord?.status))   { setChecked(true); setShowAmount(true) }      
			}
		}
	}, [selectedRecord]);

	React.useEffect(() => {
		let name = selectedRecord?.lienWaiverFile?.name.includes('.pdf') ? selectedRecord?.lienWaiverFile?.name : selectedRecord?.lienWaiverFile?.name + ".pdf";
		let fileViewerObj = {
			uri: selectedRecord?.lienWaiverFile?.stream?.downloadUrl + '?download=false&fileName=' + name
		};
		selectedRecord?.lienWaiverFile?.stream?.downloadUrl ? setFilesToView([fileViewerObj]) : setFilesToView([]);
	}, [selectedRecord?.lienWaiverFile?.stream?.downloadUrl]);

	React.useEffect(() => {
		let isValidPayment: boolean = ['UpfrontPayment', 'Retainage']?.includes(selectedRecord?.type) ? true : false;
		selectedRecord?.scheduleOfValues?.map((sov: any) => {
			!isValidPayment && sov?.payments?.find((payment: any) => {
				if(payment?.status == 'SelectedForPayment') isValidPayment = true;
			});
		});
		console.log("signn", signature, checked, filesToView?.length, showAmount, isValidPayment);
		if(checked && signature && signature != '' && filesToView?.length && showAmount && isValidPayment) dispatch(setEnableSubmitPayApp(true));
		else dispatch(setEnableSubmitPayApp(false));
	}, [signature, checked, filesToView, showAmount, selectedRecord]);

	const handleChange = (e: any) => {
		console.log("eee", e, checked);
		if(checked) {
			const isValid = isUserGCForVPA(appInfo) ? selectedRecord?.gcAuthorization?.signature != null ? true : false : selectedRecord?.scAuthorization?.signature != null ? true : false;
			isValid && patchVendorPayAppDetails(appInfo, {signedOn: null, signature: null}, selectedRecord?.id, (response: any) => {
				dispatch(setSelectedRecord(response));
				signaturePadRef.current.clear();
				// setSignature(null);                     
			});
			setShowAmount(false);
		}
		setChecked(!checked);
	};

	const saveContractAttachments = (contracts: any) => {
		const payload = {
			stream: {
				driveObjectId: contracts[0]?.uniqueId
			}
		};
		patchVendorPayAppDetails(appInfo, payload, selectedRecord?.id, (response: any) => {
			dispatch(setSelectedRecord(response));
		});
	};

	const addContractDocs = () => {
		dispatch(setShowContractAttachments(true));
	};

	const closeFileViewer = () => {
		console.log("closeeee");
		setFilesToView([]);
		patchVendorPayAppDetails(appInfo, {stream: null, signedOn: null, signature: null}, selectedRecord?.id, (response: any) => {
			dispatch(setSelectedRecord(response));
		});
		setShowAmount(false);
		setChecked(false);
		setSignedOn(null);
	};
	const clearSignature = () => {
		if(signaturePadRef?.current) {
			signaturePadRef.current.clear();
			// setSignature(null)       
		}
		patchVendorPayAppDetails(appInfo, {signedOn: null, signature: null}, selectedRecord?.id, (response: any) => {
			dispatch(setSelectedRecord(response));
		});
		setSignedOn(null);

	};

	const getSignaturePad = (signature: any, name: string, signedOn: any, label: any) => {
		return <div className="signature_section">
			<span className="common-icon-signature"></span>
			<label>{label}</label>
			<div className="signature" style={{width: '100%'}}>
				<SignatureCanvas
					ref={signaturePadRef}
					penColor="black"
					canvasProps={{
						className: "contracts-sign-modal_sig-pad",
					}}
					onEnd={() => {handleOnEnd();}}
				/>
				<div className="contracts-sign-modal_sign-above-wrapper">
					<div className="contracts-sign-modal_sign-above-txt">
						Please sign above
					</div>
					<span
						className="contracts-sign-modal_sign-eraser common-icon-eraser"
						onClick={() => clearSignature()}
					></span>
				</div>
			</div>
			<div className="lienwaiver_footerSection">
				<div className="name_div">
					<p>Name</p>
					<label className="name_data">
						{name}
					</label>
				</div>
				<div className="date_div">
					<p>Date</p>
					<label className="date_data">
						{convertDateToDisplayFormat(signedOn)}
					</label>
				</div>
			</div>
		</div>;
	};

	const getSignature = (sign: any, name: string, signedOn: any, label: any) => {
		return <>
			<span className="common-icon-signature"></span>
			<label>{label}</label>
			<Card style={{height: 200, width: 310}}><img src={sign} /></Card>
			<div className="lienwaiver_footerSection">
				<div className="name_div">
					<p>Name</p>
					<label className="name_data">
						{name}
					</label>
				</div>
				<div className="date_div">
					<p>Date</p>
					<label className="date_data">
						{signedOn ? convertDateToDisplayFormat(signedOn) : ''}
					</label>
				</div>
			</div>

		</>;

	};

	const getGCForm = (gc: any, sc: any) => {
		return <div className="awaiting-stat">
			<span className="awaiting-stat-vendor-sign">{getSignature(sc?.signature, sc?.displayName, sc?.signedOn, 'Vendor Signature')}</span>
			<span className="awaiting-stat-General-sign">{getSignaturePad(gc?.signature, gc?.displayName, gc?.signedOn, 'General Contract Signature')}</span>
		</div>;
	};
	const getSCForm = (gc: any, sc: any) => {
		return <div className="awaiting-stat">
			<span className="awaiting-stat-vendor-sign">{getSignature(gc?.signature, gc?.displayName, gc?.signedOn, 'General Contract Signature')}</span>
			<span className="awaiting-stat-General-sign">{getSignaturePad(sc?.signature, sc?.displayName, sc?.signedOn, 'Vendor Signature')}</span>
		</div>;
	};

	const getReadOnlySign = () => {
		const data = isUserGCForVPA(appInfo) ? selectedRecord?.gcAuthorization : selectedRecord?.scAuthorization;
		return <div className="sumitted-stat">{getSignature(data?.signature, data?.displayName, data?.signedOn, isUserGCForVPA(appInfo) ? 'General Contract Signature' : 'Vendor Signature')}</div>;
	};

	const getGCAndSCSigns = (gc: any, sc: any) => {
		const data = isUserGCForVPA(appInfo) ? selectedRecord?.gcAuthorization : selectedRecord?.scAuthorization;
		return <div className="auto-gen-stat">{getSignaturePad(data?.signature, data?.displayName, data?.signedOn, isUserGCForVPA(appInfo) ? 'General Contract Signature' : 'Vendor Signature')}</div>;
	};

	const getReadOnlySigns = () => {
		const gc = selectedRecord?.gcAuthorization;
		const sc = selectedRecord?.scAuthorization;

		return <div className="awaiting-stat">
			<span className="awaiting-stat-vendor-sign">{getSignature(gc?.signature, gc?.displayName, gc?.signedOn, 'General Contract Signature')}</span>
			<span className="awaiting-stat-vendor-sign">{getSignature(sc?.signature, sc?.displayName, sc?.signedOn, 'Vendor Signature')}</span>
		</div>;
	};



	const handleOnEnd = () => {
		if(signaturePadRef?.current && !signaturePadRef.current.isEmpty()) {
			const sign = signaturePadRef?.current?.getTrimmedCanvas().toDataURL("image/png");
			setSignature(sign);
			dispatch(setSignatureToAuthorize(sign));
			// selectedRecord?.status != 'AwaitingAcceptance' && patchVendorPayAppDetails(appInfo, { signature: sign, signedOn: new Date() }, selectedRecord?.id, (response: any) => {
			// 	dispatch(setSelectedRecord(response))
			// })
			setSignedOn(new Date());
		}
		else setSignature('');
	};

	const getLienWaiverFile = useCallback(() => {
		return (
			<LienFileViewer
				filesToView={filesToView}
				openContracts={addContractDocs}
				closeFileViewer={closeFileViewer}
				showClose={['Draft', 'AutoGeneratedWaitingForBothParties']?.includes(selectedRecord?.status)}
			></LienFileViewer>
		);
	}, [filesToView]);

	return (
		<div className="lienwaiver">
			<p className="lienwaiver_heading">Lien Waiver</p>
			<div className="lienwaiver_firstSection"></div>

			{openContractAttachments ? (
				<ContractAttachments
					rowSelection={'single'}
					open={true}
					categories={[5]}
					onAdd={(list: any) => saveContractAttachments(list)}
					onClose={() => dispatch(setShowContractAttachments(false))}
				/>
			) : (
				""
			)}

			<div className="vendor-lienwaiver-secondSection">
				{getLienWaiverFile()}
				<div className="secondsection_Content">
					<p className="second_content2">
						<Checkbox checked={checked} onChange={(e: any) => handleChange(e)} disabled={["AutoGeneratedWaitingForBothParties", "Draft", "AwaitingAcceptance"]?.includes(selectedRecord?.status) ? false : true} />
						The undersigned further hereby acknowledges that the sum of
						{["Draft", "AwaitingAcceptance", "AutoGeneratedWaitingForBothParties"]?.includes(selectedRecord?.status) && !showAmount ? (
							<span className="amount_section">
								<Button
									variant="outlined"
									startIcon={<span className="common-icon-add-circle" />}
									onClick={() => {
										setShowAmount(true);
									}}
								>
									Insert Total Payout Amount
								</Button>
							</span>
						) : (
							<span className="amount">{` ${selectedRecord?.amount
								? toWords.convert(selectedRecord?.amount)
								: ""
								} `}</span>
						)}
						{currencyDescription?.[appInfo?.currencyType] ?? 'Dollars'}
						<span className="bracket">
							(</span>
						<span className="amount">
							{" "}
							{["Draft", "AwaitingAcceptance", "AutoGeneratedWaitingForBothParties"]?.includes(selectedRecord?.status) && !showAmount
								? ""
								: amountFormatWithSymbol(selectedRecord?.amount)}
						</span>
						<span className="bracket">)
						</span>
						constitutes the entire unpaid balance due the undersigned in
						connection with said project whether under said contract or
						otherwise and that the payment of said sum to the Contractor will
						constitute payment in full and will fully satisfy any and all liens,
						claims, and demands which the Contractor may have or assert against
						the Owner in connection which said contract or project.
					</p>
				</div>
				{
					selectedRecord?.status == 'Draft' ? <div className="signature_section">
						<span className="common-icon-signature"></span>
						<label>{isUserGCForVPA(appInfo) ? 'General Contractor Signature' : 'Vendor Signature'}</label>
						<div className="signature" style={{width: '100%'}}>
							<SignatureCanvas
								ref={signaturePadRef}
								penColor="black"
								canvasProps={{
									// width: 1037,
									//height: 200,
									className: "contracts-sign-modal_sig-pad",
								}}
								onEnd={() => {handleOnEnd();}}
							/>
							<div className="contracts-sign-modal_sign-above-wrapper">
								<div className="contracts-sign-modal_sign-above-txt">
									Please sign above
								</div>
								<span
									className="contracts-sign-modal_sign-eraser common-icon-eraser"
									onClick={() => clearSignature()}
								></span>
							</div>
						</div>
						<div className="lienwaiver_footerSection">
							<div className="name_div">
								<p>Name</p>
								<label className="name_data">
									{userDetails?.name}
								</label>
							</div>
							<div className="date_div">
								<p>Date</p>
								<label className="date_data">
									{convertDateToDisplayFormat(userDetails?.signedOn)}
								</label>
							</div>
						</div>
					</div>
						: selectedRecord?.status == 'AwaitingAcceptance' ?
							isUserGCForVPA(appInfo) ? <div>{getGCForm(selectedRecord?.gcAuthorization, selectedRecord?.scAuthorization)}</div> : <div>{getSCForm(selectedRecord?.gcAuthorization, selectedRecord?.scAuthorization)}</div>
							: selectedRecord?.status == 'SubmittedWaitingForOtherParty' ? getReadOnlySign() : selectedRecord?.status == 'AutoGeneratedWaitingForBothParties' ? getGCAndSCSigns(selectedRecord?.gcAuthorization, selectedRecord?.scAuthorization) : getReadOnlySigns()
				}

			</div>
		</div>
	);
};
export default LienWaiver;