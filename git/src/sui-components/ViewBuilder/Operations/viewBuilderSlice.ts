import { createAsyncThunk, createSlice, PayloadAction, combineReducers } from '@reduxjs/toolkit';
import { fetchViewBuilderData, fetchView } from './viewBuilderAPI';

export interface ViewbuilderState {
	loading: boolean;
	viewBuilderData: any;
	viewData: any;
}

const initialState: ViewbuilderState = {
	loading: false,
	viewBuilderData: [],
	viewData: {},
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const fetchViewBuilderList = createAsyncThunk<any, any>(
	'viewBuilder',
	async (data) => {
		const response = await fetchViewBuilderData(data?.appInfo, data?.modulename);
		const newOptions = response.data.map((type: any) => {
			return { text: type.viewName, value: type };
		});
		return newOptions;
	}

);
export const fetchViewData = createAsyncThunk<any, any>('view', async (data) => {
	const response = await fetchView(data.appInfo, data.viewId);
	const newOptions = { ...response, text: response.viewName, value: 'type' }
	return newOptions;
});

export const viewBuilderSlice = createSlice({
	name: 'viewbuilder',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setViewBuilderList: (state, action: PayloadAction<any>) => {
			state.viewBuilderData = action.payload;
		},
		setViewData: (state, action: PayloadAction<any>) => {
			state.viewData = action.payload;
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(fetchViewBuilderList.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchViewBuilderList.fulfilled, (state, action) => {
				state.loading = false;
				state.viewBuilderData = action.payload;
				action.payload.map((view: any) => {
					if (view.value.defaultView) state.viewData = view.value;
				})
			})
			.addCase(fetchViewBuilderList.rejected, (state) => {
				state.loading = false;
			})
			.addCase(fetchViewData.pending, (state) => {
				state.loading = true;
			})
			.addCase(fetchViewData.fulfilled, (state, action) => {
				state.loading = false;
				state.viewData = action.payload;
			})
			.addCase(fetchViewData.rejected, (state) => {
				state.loading = false;
			})
	}
});



export const { setViewBuilderList, setViewData } = viewBuilderSlice.actions;

export default viewBuilderSlice.reducer;
